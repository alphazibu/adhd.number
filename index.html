<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Focus Density - Optimized</title>
<style>
:root{--m:#7cfbff}
body{margin:0;height:100vh;overflow:hidden;display:flex;justify-content:center;align-items:center;background:#020808;color:#fff;font-family:system-ui;user-select:none}
#b{position:absolute;inset:0;filter:blur(100px);z-index:-3;transition:background 2s;will-change:background}
canvas{position:absolute;inset:0;z-index:-2;pointer-events:none}
.c{width:340px;text-align:center;position:relative}
.cnt{font-size:8rem;font-weight:100;line-height:1;font-variant-numeric:tabular-nums}
.g{text-shadow:0 0 35px var(--m);color:#fff}
.r{margin-top:40px;opacity:.3;font-size:.9rem;letter-spacing:1px}
.p{font-size:1.8rem;color:var(--m);position:absolute;left:50%;bottom:0;transform:translateX(-50%);opacity:0;font-weight:bold}
</style>
</head>
<body>
<div id="b"></div>
<canvas id="v"></canvas>

<div class="c">
    <div class="cnt" id="x1">0</div>
    <div class="r" id="x3">×1</div>
    <div id="x4" class="p"></div>
</div>

<script>
const D=document, X1=D.getElementById('x1'), X3=D.getElementById('x3'), X4=D.getElementById('x4'), B=D.getElementById('b');

// データ管理
let s = JSON.parse(localStorage.getItem('fd_l')) || {c:0, m:1};
s.c = Number(s.c); s.m = Number(s.m);

// 定数
const LV_UP = 10000;

// アニメーション: 離席復帰時のスコア加算表示
const showPop = (val) => {
    X4.textContent = `+${Math.floor(val)}`;
    X4.animate([
        { transform: 'translateX(-50%) translateY(0)', opacity: 1 },
        { transform: 'translateX(-50%) translateY(-60px)', opacity: 0 }
    ], { duration: 800, easing: 'ease-out' });
};

// 背景色・テーマ更新（1分に1回程度で十分）
const updateTheme = () => {
    const h = new Date().getHours();
    const t = h<6 ? ["#7b5cff","#2b145c"] : h<12 ? ["#7cfbff","#a0f0ff"] : h<18 ? ["#5effc6","#7cffd6"] : ["#ffb86c","#ff8c42"];
    D.documentElement.style.setProperty("--m", t[0]);
    B.style.background = `radial-gradient(circle, ${t[1]}, #000)`;
};
updateTheme();
setInterval(updateTheme, 60000);

let lastTime = performance.now();
let lastSave = 0;

// メインループ
function tick(t) {
    const dt = (t - lastTime) / 1000;
    lastTime = t;

    if (!D.hidden) {
        s.c += dt;
        
        // レベルアップ判定
        if (s.c >= LV_UP) {
            s.c -= LV_UP;
            s.m++;
            X1.classList.add('g');
            setTimeout(() => X1.classList.remove('g'), 500);
            if (window.gtag) gtag('event', 'level_up', { 'level': s.m });
        }

        // 表示更新（整数部が変わった時だけDOM操作）
        const displayVal = Math.floor(s.c).toLocaleString();
        if (X1.textContent !== displayVal) {
            X1.textContent = displayVal;
            X3.textContent = '×' + s.m;
        }
    }

    // ストレージ保存（1秒に1回程度に抑える）
    if (t - lastSave > 1000) {
        localStorage.setItem('fd_l', JSON.stringify(s));
        lastSave = t;
    }
    requestAnimationFrame(tick);
}

// 離席復帰処理
let leaveTime = Date.now();
D.addEventListener('visibilitychange', () => {
    if (D.hidden) {
        leaveTime = Date.now();
    } else {
        const gap = (Date.now() - leaveTime) / 1000;
        if (gap >= 1) {
            s.c += gap;
            showPop(gap);
        }
        lastTime = performance.now();
    }
});

// Canvasパーティクル
const cv = D.getElementById('v'), ct = cv.getContext('2d', { alpha: false });
const res = () => { cv.width = innerWidth; cv.height = innerHeight; };
window.addEventListener('resize', res);
res();

const ps = Array.from({length: 120}, () => ({
    x: Math.random() * cv.width,
    y: Math.random() * cv.height,
    vx: (Math.random() - 0.5) * 0.4,
    vy: (Math.random() - 0.5) * 0.4,
    o: Math.random()
}));

function draw() {
    ct.fillStyle = '#020808'; // 背景色で塗りつぶし（clearRectより早い場合がある）
    ct.fillRect(0, 0, cv.width, cv.height);
    ct.fillStyle = '#fff';
    
    ps.forEach(p => {
        p.x = (p.x + p.vx + cv.width) % cv.width;
        p.y = (p.y + p.vy + cv.height) % cv.height;
        ct.globalAlpha = p.o;
        ct.fillRect(p.x, p.y, 1.5, 1.5); // arcよりfillRectの方が描画コストが低い
    });
    ct.globalAlpha = 1;
    requestAnimationFrame(draw);
}

requestAnimationFrame(tick);
requestAnimationFrame(draw);
</script>
</body>
</html>
